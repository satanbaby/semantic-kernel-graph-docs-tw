# é€²éšæ¨¡å¼ç¤ºä¾‹

æœ¬ç¤ºä¾‹æ¼”ç¤ºäº†èªæ„æ ¸å¿ƒåœ–ä¸­é€²éšæ¶æ§‹æ¨¡å¼çš„å…¨é¢æ•´åˆï¼ŒåŒ…æ‹¬å­¸è¡“æ¨¡å¼ã€æ©Ÿå™¨å­¸ç¿’æœ€ä½³åŒ–å’Œä¼æ¥­æ•´åˆåŠŸèƒ½ã€‚

## ç›®æ¨™

å­¸ç¿’å¦‚ä½•åœ¨åŸºæ–¼åœ–å½¢çš„å·¥ä½œæµä¸­å¯¦ç¾å’Œå”èª¿é€²éšæ¨¡å¼ï¼Œä»¥ä¾¿ï¼š
* é…ç½®å’Œä½¿ç”¨å­¸è¡“æ¨¡å¼ï¼ˆæ–·è·¯å™¨ã€è‰™å£ã€æ—è·¯å¿«å–ï¼‰
* å•Ÿç”¨åŸºæ–¼æ©Ÿå™¨å­¸ç¿’çš„æ•ˆèƒ½é æ¸¬å’Œç•°å¸¸åµæ¸¬
* å¯¦ç¾åˆ†æ•£å¼ç³»çµ±çš„ä¼æ¥­æ•´åˆæ¨¡å¼
* åœ¨çœŸå¯¦ä¸–ç•Œå ´æ™¯ä¸­å”èª¿å¤šå€‹æ¨¡å¼
* å…¨é¢ç›£æ§å’Œè¨ºæ–·æ¨¡å¼æ•ˆèƒ½

## å…ˆæ±ºæ¢ä»¶

* **.NET 8.0** æˆ–æ›´é«˜ç‰ˆæœ¬
* **OpenAI API é‡‘é‘°**å·²åœ¨ `appsettings.json` ä¸­è¨­å®š
* **èªæ„æ ¸å¿ƒåœ–å¥—ä»¶**å·²å®‰è£
* å°[åœ–å½¢æ¦‚å¿µ](../concepts/graph-concepts.md)å’Œ[åŸ·è¡Œæ¨¡å‹](../concepts/execution-model.md)çš„åŸºæœ¬ç†è§£
* ç†Ÿæ‚‰[éŒ¯èª¤è™•ç†å’Œå¾©åŸèƒ½åŠ›](../how-to/error-handling-and-resilience.md)

## ä¸»è¦å…ƒä»¶

### æ¦‚å¿µå’ŒæŠ€è¡“

* **å­¸è¡“æ¨¡å¼**ï¼šä¼æ¥­ç´šå¾©åŸèƒ½åŠ›æ¨¡å¼ï¼ŒåŒ…æ‹¬æ–·è·¯å™¨ã€è‰™å£å’Œæ—è·¯å¿«å–
* **æ©Ÿå™¨å­¸ç¿’æœ€ä½³åŒ–**ï¼šä½¿ç”¨æ­·å²åŸ·è¡Œè³‡æ–™é€²è¡Œæ•ˆèƒ½é æ¸¬å’Œç•°å¸¸åµæ¸¬
* **ä¼æ¥­æ•´åˆ**ï¼šè¨Šæ¯è·¯ç”±ã€å…§å®¹å‹è·¯ç”±ã€ç™¼å¸ƒ-è¨‚é–±å’Œèšåˆæ¨¡å¼
* **æ¨¡å¼å”èª¿**ï¼šå”èª¿åŸ·è¡Œå¤šå€‹æ¨¡å¼ä¸¦é€²è¡Œå…¨é¢è¨ºæ–·

### æ ¸å¿ƒé¡åˆ¥

* `GraphExecutor`ï¼šé€é `WithAllAdvancedPatterns` æ”¯æ´é€²éšæ¨¡å¼çš„å¢å¼·åŸ·è¡Œå™¨
* `AcademicPatterns`ï¼šæ–·è·¯å™¨ã€è‰™å£å’Œæ—è·¯å¿«å–å¯¦ç¾
* `MachineLearningOptimizer`ï¼šæ•ˆèƒ½é æ¸¬å’Œç•°å¸¸åµæ¸¬å¼•æ“
* `EnterpriseIntegrationPatterns`ï¼šè¨Šæ¯è·¯ç”±å’Œè™•ç†æ¨¡å¼
* `GraphPerformanceMetrics`ï¼šå…¨é¢æ•ˆèƒ½è¿½è¹¤å’Œåˆ†æ

## åŸ·è¡Œç¤ºä¾‹

### å…¥é–€

æœ¬ç¤ºä¾‹æ¼”ç¤ºäº†èªæ„æ ¸å¿ƒåœ–å¥—ä»¶çš„é€²éšæ¨¡å¼å’Œæœ€ä½³åŒ–ã€‚ä¸‹é¢çš„ç¨‹å¼ç¢¼ç‰‡æ®µå‘æ‚¨å±•ç¤ºå¦‚ä½•åœ¨è‡ªå·±çš„æ‡‰ç”¨ç¨‹å¼ä¸­å¯¦ç¾é€™äº›æ¨¡å¼ã€‚

## é€æ­¥å¯¦ç¾

### 1. å»ºç«‹é€²éšåœ–åŸ·è¡Œå™¨

è©²ç¤ºä¾‹é¦–å…ˆå»ºç«‹å•Ÿç”¨äº†æ‰€æœ‰é€²éšæ¨¡å¼çš„åœ–åŸ·è¡Œå™¨ã€‚

```csharp
// ä½¿ç”¨æä¾›çš„æ ¸å¿ƒå’Œåœ–è¨˜éŒ„å™¨å»ºç«‹ GraphExecutorã€‚
// æ­¤ç‰‡æ®µç‚ºæ¼”ç¤ºé…ç½®äº†ä¸€çµ„æœ€å°ã€å®‰å…¨çš„é€²éšæ¨¡å¼ã€‚
var executor = new GraphExecutor(kernel, graphLogger);

// ä½¿ç”¨ä¿å®ˆé è¨­å€¼å•Ÿç”¨ä¸»è¦å­¸è¡“å¾©åŸèƒ½åŠ›æ¨¡å¼ã€‚
executor.WithAllAdvancedPatterns(config =>
{
    // å•Ÿç”¨å­¸è¡“å¾©åŸèƒ½åŠ›æ¨¡å¼ï¼ˆæ–·è·¯å™¨ã€è‰™å£ã€æ—è·¯å¿«å–ï¼‰ã€‚
    config.EnableAcademicPatterns = true;
    config.Academic.EnableCircuitBreaker = true;
    config.Academic.EnableBulkhead = true;
    config.Academic.EnableCacheAside = true;

    // æ–·è·¯å™¨ï¼š3 æ¬¡å¤±æ•—å¾Œè·³é–˜ï¼Œä¿æŒçŸ­æ™‚é–“é–‹å•Ÿã€‚
    config.Academic.CircuitBreakerOptions.FailureThreshold = 3;
    config.Academic.CircuitBreakerOptions.OpenTimeout = TimeSpan.FromSeconds(10);

    // è‰™å£ï¼šé™åˆ¶ä¸¦è¡Œæ€§ä»¥é¿å…æ¼”ç¤ºä¸­çš„è³‡æºè€—ç›¡ã€‚
    config.Academic.BulkheadOptions.MaxConcurrency = 5;
    config.Academic.BulkheadOptions.AcquisitionTimeout = TimeSpan.FromSeconds(15);

    // æ—è·¯å¿«å–ï¼šç”¨æ–¼æ¼”ç¤ºçš„å°å‹è¨˜æ†¶é«”å…§å¿«å–ã€‚
    config.Academic.CacheAsideOptions.MaxCacheSize = 1000;
    config.Academic.CacheAsideOptions.DefaultTtl = TimeSpan.FromMinutes(10);
});
```

### 2. å­¸è¡“æ¨¡å¼æ¼”ç¤º

#### æ–·è·¯å™¨æ¨¡å¼

```csharp
// é€éåŸ·è¡Œå™¨çš„æ–·è·¯å™¨å¹«åŠ©å™¨åŸ·è¡Œå—ä¿è­·çš„æ“ä½œã€‚
// æ“ä½œæ‡‰ç‚ºéåŒæ­¥å§”æ´¾ï¼›ç•¶æ–·è·¯å™¨é–‹å•Ÿæˆ–ç™¼ç”Ÿå¤±æ•—æ™‚åŸ·è¡Œå‚™ç”¨æ–¹æ¡ˆã€‚
var circuitBreakerTest = await executor.ExecuteWithCircuitBreakerAsync(
    operation: async () =>
    {
        // æ¨¡æ“¬ä¸€äº›å·¥ä½œ
        await Task.Delay(100);
        Console.WriteLine("Operation executed successfully");
        return "Success";
    },
    fallback: async () =>
    {
        // ç”¨æ–¼æ¼”ç¤ºçš„æœ€å°å‚™ç”¨å¯¦ç¾
        Console.WriteLine("Fallback operation executed");
        return "Fallback";
    });
```

#### è‰™å£æ¨¡å¼

```csharp
// ä½¿ç”¨è‰™å£ä¸¦è¡ŒåŸ·è¡Œå¤šå€‹æ“ä½œä»¥ä¿è­·è³‡æºã€‚
var bulkheadTasks = Enumerable.Range(1, 3).Select(async i =>
{
    return await executor.ExecuteWithBulkheadAsync(async (cancellationToken) =>
    {
        await Task.Delay(200, cancellationToken);
        Console.WriteLine($"Bulkhead operation {i} completed");
        return $"Result-{i}";
    });
});

var bulkheadResults = await Task.WhenAll(bulkheadTasks);
```

#### æ—è·¯å¿«å–æ¨¡å¼

```csharp
// æ—è·¯å¿«å–æ¨¡å¼ï¼šå¿«å–æœªå‘½ä¸­æ™‚å‘¼å«è¼‰å…¥å™¨ä»¥å¡«å……å¿«å–ã€‚
var cacheResult1 = await executor.GetOrSetCacheAsync(
    key: "user_profile_123",
    loader: async () =>
    {
        // æ¨¡æ“¬ç·©æ…¢çš„è³‡æ–™ä¾†æºï¼ˆè³‡æ–™åº«ï¼‰
        await Task.Delay(500);
        Console.WriteLine("Loading from database (cache miss)");
        return new { UserId = 123, Name = "John Doe", Email = "john@example.com" };
    });

// ç¬¬äºŒæ¬¡å‘¼å«æ‡‰ç‚ºå¿«å–å‘½ä¸­ï¼Œä¸æœƒå‘¼å«è¼‰å…¥å™¨å§”æ´¾ã€‚
var cacheResult2 = await executor.GetOrSetCacheAsync(
    key: "user_profile_123",
    loader: async () =>
    {
        // å¦‚æœåœ¨æ‚¨çš„ç’°å¢ƒä¸­åŸ·è¡Œï¼Œå‰‡å¿«å–æœªæ­£å¸¸é‹ä½œã€‚
        Console.WriteLine("Loader unexpectedly invoked on supposed cache hit");
        return new { UserId = 123, Name = "John Doe", Email = "john@example.com" };
    });
```

### 3. é€²éšæœ€ä½³åŒ–

è©²ç¤ºä¾‹æ¼”ç¤ºäº†åŸºæ–¼æ­·å²æŒ‡æ¨™çš„æ•ˆèƒ½æœ€ä½³åŒ–ã€‚

```csharp
// å»ºç«‹å°å‹æŒ‡æ¨™ç‰©ä»¶ä¸¦æ¨¡æ“¬åŸ·è¡Œä»¥ç”¢ç”Ÿç¯„ä¾‹è³‡æ–™ã€‚
var metrics = new GraphPerformanceMetrics(new GraphMetricsOptions(), graphLogger);

for (int i = 0; i < 5; i++)
{
    var tracker = metrics.StartNodeTracking($"node_{i % 2}", $"TestNode{i % 2}", $"exec_{i}");
    await Task.Delay(Random.Shared.Next(50, 150));
    metrics.CompleteNodeTracking(tracker, success: true);
}

// ä½¿ç”¨æ¨¡æ“¬æŒ‡æ¨™åŸ·è¡Œè¼•é‡ç´šæœ€ä½³åŒ–åˆ†æã€‚
var optimizationResult = await executor.OptimizeAsync(metrics);
Console.WriteLine($"Analysis completed in {optimizationResult.AnalysisTime.TotalMilliseconds:F2}ms");
Console.WriteLine($"Total optimizations identified: {optimizationResult.TotalOptimizations}");
```

### 4. æ©Ÿå™¨å­¸ç¿’æœ€ä½³åŒ–

#### æ•ˆèƒ½é æ¸¬

```csharp
// æº–å‚™ç”¨æ–¼é æ¸¬æ¼”ç¤ºçš„å°å‹åœ–å½¢çµ„æ…‹ã€‚
var graphConfig = new GraphConfiguration
{
    NodeCount = 8,
    AveragePathLength = 3.5,
    ConditionalNodeCount = 2,
    LoopNodeCount = 1,
    ParallelNodeCount = 2
};

// å‘åŸ·è¡Œå™¨è¦æ±‚æ•ˆèƒ½é æ¸¬ï¼ˆéœ€è¦å•Ÿç”¨æ©Ÿå™¨å­¸ç¿’ï¼‰ã€‚
var prediction = await executor.PredictPerformanceAsync(graphConfig);
Console.WriteLine($"Predicted latency: {prediction.PredictedLatency.TotalMilliseconds:F2}ms");
Console.WriteLine($"Confidence: {prediction.Confidence:P2}");
Console.WriteLine($"Recommended optimizations: {prediction.RecommendedOptimizations.Count}");
```

#### ç•°å¸¸åµæ¸¬

```csharp
// ç•°å¸¸åµæ¸¬è¼¸å…¥ç¤ºä¾‹ï¼ˆæ¨¡æ“¬æŒ‡æ¨™ï¼‰ã€‚
var executionMetrics = new GraphExecutionMetrics
{
    TotalExecutionTime = TimeSpan.FromMilliseconds(5000),
    CpuUsage = 85.0,
    MemoryUsage = 75.0,
    ErrorRate = 2.0,
    ThroughputPerSecond = 10.0
};

var anomalyResult = await executor.DetectAnomaliesAsync(executionMetrics);
Console.WriteLine($"Is anomaly: {anomalyResult.IsAnomaly}");
Console.WriteLine($"Anomaly score: {anomalyResult.AnomalyScore:F2}");
Console.WriteLine($"Confidence: {anomalyResult.Confidence:P2}");
```

### 5. ä¼æ¥­æ•´åˆæ¨¡å¼

#### è¨Šæ¯è·¯ç”±

```csharp
// å®šç¾©ä¸€å€‹ç°¡å–®çš„è¨Šæ¯è·¯ç”±è¦å‰‡ï¼Œè½‰ç™¼ã€ŒOrderCreatedã€è¨Šæ¯ã€‚
var messageRoute = new IntegrationRoute
{
    Type = IntegrationRouteType.Message,
    Source = "orders",
    Destination = "fulfillment",
    Conditions = new Dictionary<string, object>
    {
        ["MessageType"] = "OrderCreated",
        ["Priority"] = MessagePriority.High
    }
};

var routeId = await executor.ConfigureIntegrationRouteAsync(messageRoute);
Console.WriteLine($"Route configured with id: {routeId}");
```

#### è™•ç†ä¸åŒæ¨¡å¼

```csharp
// æº–å‚™å¹¾å€‹ç”¨æ–¼è·¯ç”±æ¼”ç¤ºçš„ç¯„ä¾‹ä¼æ¥­è¨Šæ¯ã€‚
var testMessages = new[]
{
    new EnterpriseMessage
    {
        MessageType = "OrderCreated",
        Priority = MessagePriority.High,
        Payload = new { OrderId = "ORD-001", CustomerId = "CUST-123", Amount = 299.99 },
        Routing = new RoutingProperties { RoutingKey = "orders", Topic = "order-events" }
    },
    new EnterpriseMessage
    {
        MessageType = "PaymentProcessed",
        Priority = MessagePriority.Normal,
        Payload = new { PaymentId = "PAY-001", OrderId = "ORD-001", Status = "Completed" },
        Routing = new RoutingProperties { RoutingKey = "payments", Topic = "payment-events" }
    }
};

foreach (var message in testMessages)
{
    Console.WriteLine($"Processing message: {message.MessageType}");

    // è¨Šæ¯è·¯ç”±å™¨
    var routerContext = new ProcessingContext
    {
        ProcessingPattern = IntegrationPattern.MessageRouter,
        RoutingKey = message.Routing.RoutingKey,
        ProcessingTimeout = TimeSpan.FromSeconds(30)
    };

    var routerResult = await executor.ProcessEnterpriseMessageAsync(message, routerContext);
    Console.WriteLine($"Message Router: {(routerResult.Success ? "OK" : "FAIL")} ({routerResult.ProcessingTime.TotalMilliseconds:F2}ms)");

    // å…§å®¹å‹è·¯ç”±å™¨
    var contentContext = new ProcessingContext
    {
        ProcessingPattern = IntegrationPattern.ContentBasedRouter,
        ProcessingTimeout = TimeSpan.FromSeconds(30)
    };

    var contentResult = await executor.ProcessEnterpriseMessageAsync(message, contentContext);
    Console.WriteLine($"Content Router: {(contentResult.Success ? "OK" : "FAIL")} ({contentResult.ProcessingTime.TotalMilliseconds:F2}ms)");

    // ç™¼å¸ƒ-è¨‚é–±
    var pubSubContext = new ProcessingContext
    {
        ProcessingPattern = IntegrationPattern.PublishSubscribe,
        Topic = message.Routing.Topic,
        ProcessingTimeout = TimeSpan.FromSeconds(30)
    };

    var pubSubResult = await executor.ProcessEnterpriseMessageAsync(message, pubSubContext);
    Console.WriteLine($"Pub-Sub: {(pubSubResult.Success ? "OK" : "FAIL")} ({pubSubResult.ProcessingTime.TotalMilliseconds:F2}ms)");
}
```

### 6. å…¨é¢è¨ºæ–·

è©²ç¤ºä¾‹ä»¥æ‰€æœ‰æ¨¡å¼çš„å…¨é¢è¨ºæ–·çµæŸã€‚

```csharp
// åŸ·è¡Œå…¨é¢è¨ºæ–·ä¾‹è¡Œç¨‹åºä¸¦åˆ—å°ç²¾ç°¡å ±å‘Šã€‚
var diagnosticReport = await executor.RunComprehensiveDiagnosticsAsync(metrics);

Console.WriteLine($"\nDiagnostic Report (Generated at {diagnosticReport.Timestamp:HH:mm:ss})");
Console.WriteLine(new string('=', 60));

Console.WriteLine($"Success: {diagnosticReport.Success}");
Console.WriteLine($"Executor ID: {diagnosticReport.GraphExecutorId}");

if (diagnosticReport.AcademicPatternsStatus != null)
{
    var status = diagnosticReport.AcademicPatternsStatus;
    Console.WriteLine($"Circuit Breaker configured: {status.CircuitBreakerConfigured}");
    Console.WriteLine($"Bulkhead configured: {status.BulkheadConfigured}");
    Console.WriteLine($"Cache-Aside configured: {status.CacheAsideConfigured}");
}

if (diagnosticReport.OptimizationAnalysis != null)
{
    var opt = diagnosticReport.OptimizationAnalysis;
    Console.WriteLine($"Optimization analysis time: {opt.AnalysisTime.TotalMilliseconds:F2}ms");
    Console.WriteLine($"Total optimizations: {opt.TotalOptimizations}");
}
```

## é æœŸè¼¸å‡º

è©²ç¤ºä¾‹ç”¢ç”Ÿå…¨é¢çš„è¼¸å‡ºï¼Œé¡¯ç¤ºï¼š

* âœ… å»ºç«‹å•Ÿç”¨æ‰€æœ‰æ¨¡å¼çš„é€²éšåœ–åŸ·è¡Œå™¨
* ğŸ“ å­¸è¡“æ¨¡å¼æ¼”ç¤ºï¼ˆæ–·è·¯å™¨ã€è‰™å£ã€æ—è·¯å¿«å–ï¼‰
* âš¡ å…·æœ‰æ•ˆèƒ½å»ºè­°çš„é€²éšæœ€ä½³åŒ–åˆ†æ
* ğŸ¤– æ©Ÿå™¨å­¸ç¿’è¨“ç·´å’Œæ•ˆèƒ½é æ¸¬
* ğŸ¢ ä¼æ¥­æ•´åˆæ¨¡å¼ï¼ˆè¨Šæ¯è·¯ç”±å™¨ã€å…§å®¹è·¯ç”±å™¨ã€ç™¼å¸ƒ-è¨‚é–±ï¼‰
* ğŸ” æ‰€æœ‰æ¨¡å¼çš„å…¨é¢è¨ºæ–·å ±å‘Š

## ç–‘é›£æ’è§£

### å¸¸è¦‹å•é¡Œ

1. **æ¨¡å¼çµ„æ…‹éŒ¯èª¤**ï¼šç¢ºä¿æ‰€æœ‰æ¨¡å¼é¸é …åœ¨å‘¼å« `WithAllAdvancedPatterns` ä¹‹å‰éƒ½å·²æ­£ç¢ºé…ç½®
2. **æ©Ÿå™¨å­¸ç¿’è¨“ç·´å¤±æ•—**ï¼šæª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ çš„æ­·å²è³‡æ–™å¯ç”¨æ–¼è¨“ç·´
3. **æ•´åˆè·¯ç”±éŒ¯èª¤**ï¼šé©—è­‰è¨Šæ¯è·¯ç”±æ¢ä»¶å’Œç›®æ¨™çµ„æ…‹
4. **æ•ˆèƒ½å•é¡Œ**ï¼šç›£æ§æœ€ä½³åŒ–åˆ†æè¨ˆæ™‚ä¸¦æ ¹æ“šéœ€è¦èª¿æ•´é–¾å€¼

### é™¤éŒ¯æç¤º

* å•Ÿç”¨è©³ç´°è¨˜éŒ„ä»¥è¿½è¹¤æ¨¡å¼åŸ·è¡Œ
* ä½¿ç”¨å…¨é¢è¨ºæ–·ä¾†è­˜åˆ¥çµ„æ…‹å•é¡Œ
* ç›£æ§æ–·è·¯å™¨ç‹€æ…‹å’Œè‰™å£ä¸¦è¡Œé™åˆ¶
* æª¢æŸ¥å¿«å–å‘½ä¸­ç‡å’Œæ©Ÿå™¨å­¸ç¿’æ¨¡å‹è¨“ç·´ç‹€æ…‹

## å¦è«‹åƒé–±

* [éŒ¯èª¤è™•ç†å’Œå¾©åŸèƒ½åŠ›](../how-to/error-handling-and-resilience.md)
* [è³‡æºæ²»ç†å’Œä¸¦è¡Œ](../how-to/resource-governance-and-concurrency.md)
* [æŒ‡æ¨™å’Œå¯è§€æ¸¬æ€§](../how-to/metrics-and-observability.md)
* [æ•´åˆå’Œæ“´å……](../how-to/integration-and-extensions.md)
* [é€²éšè·¯ç”±](../how-to/advanced-routing.md)
